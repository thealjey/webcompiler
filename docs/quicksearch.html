<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Compiler.js.html":{"id":"Compiler.js.html","title":"Source: Compiler.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: Compiler.js /* @flow */ import type {ProgramData, ProgramDataCallback} from './typedef'; import mkdirp from 'mkdirp'; import {dirname} from 'path'; import {writeFile, readFile} from 'fs'; import {gzip, gunzip} from 'zlib'; /* eslint-disable no-process-env */ let i = 0; /** * The base compiler class * * @class Compiler * @abstract * @param {boolean} [compress=true] - if true `Compiler#save` will gzip compress the data in production mode */ export class Compiler { /** * True if the NODE_ENV environment variable is equal to `production`. * * Caution: modifying it's value directly may lead to unexpected results * * @member {boolean} isProduction * @memberof Compiler * @readOnly * @instance */ isProduction: boolean; /** * if true `Compiler#save` will gzip compress the data * * @member {boolean} compress * @memberof Compiler * @private * @instance */ compress: boolean; /* eslint-disable require-jsdoc */ constructor(compress: boolean = true) { /* eslint-enable require-jsdoc */ this.isProduction = 'production' === process.env.NODE_ENV; this.compress = this.isProduction &amp;&amp; compress; } /** * Executed when the compilation is complete * * @memberOf Compiler * @static * @method done * @param {string} inPath - the input path * @param {Function} callback - a callback function * @example * Compiler.done('/path/to/an/input/file', callback); */ static done(inPath: string, callback: () =&gt; void) { console.log('\\x1b[32m%s. Compiled %s\\x1b[0m', ++i, inPath); callback(); } /** * Writes the data to disk and then calls `done`. * * @memberOf Compiler * @static * @private * @method writeAndCallDone * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {ProgramData} data - processed application code with source maps * @param {Function} callback - a callback function * @return {void} * @example * Compiler.writeAndCallDone('/path/to/an/input/file', '/path/to/the/output/file', data, callback); */ static writeAndCallDone(inPath: string, outPath: string, data: ProgramData, callback: () =&gt; void) { if (!data.code) { return Compiler.done(inPath, callback); } Compiler.fsWrite(outPath, data, () =&gt; { Compiler.done(inPath, callback); }); } /** * Writes the data to disk * * @memberOf Compiler * @static * @method fsWrite * @param {string} path - the output path * @param {ProgramData} data - the data to write * @param {Function} callback - a callback function * @example * Compiler.fsWrite('/path/to/an/output/file', data, callback); */ static fsWrite(path: string, data: ProgramData, callback: () =&gt; void) { Compiler.mkdir(path, () =&gt; { writeFile(path, data.code, scriptErr =&gt; { if (scriptErr) { return console.error(scriptErr); } if (!data.map) { return callback(); } writeFile(`${path}.map`, data.map, mapErr =&gt; { if (mapErr) { return console.error(mapErr); } callback(); }); }); }); } /** * Recursively creates a directory containing a file specified by `path`. * * @memberOf Compiler * @static * @method mkdir * @param {string} path - a path to a file * @param {Function} callback - a callback function * @example * Compiler.mkdir('/path/to/a/file', callback); */ static mkdir(path: string, callback: () =&gt; void) { mkdirp(dirname(path), mkdirpErr =&gt; { if (mkdirpErr) { return console.error(mkdirpErr); } callback(); }); } /** * G-zips the compiled code * * @memberOf Compiler * @static * @method gzip * @param {ProgramData} data - the actual program data to auto-prefix * @param {ProgramDataCallback} callback - a callback function * @return {void} * @example * Compiler.gzip(data, callback); */ static gzip(data: ProgramData, callback: ProgramDataCallback) { if (!data.code) { return callback(data); } /* @flowignore */ gzip(data.code, (err, code) =&gt; { if (err) { return console.error(err); } callback({code, map: data.map}); }); } /** * Reads the data from disk * * @memberOf Compiler * @private * @method fsRead * @param {string} path - the input path * @param {ProgramDataCallback} callback - a callback function * @example * Compiler.fsRead('/path/to/an/output/file', callback); */ fsRead(path: string, callback: ProgramDataCallback) { readFile(path, (scriptErr, scriptData) =&gt; { readFile(`${path}.map`, 'utf8', (mapErr, mapData) =&gt; { const map = mapErr ? '' : mapData; if (scriptErr) { return callback({code: '', map}); } if (!this.compress) { return callback({code: scriptData.toString('utf8'), map}); } /* @flowignore */ gunzip(scriptData, (zipErr, zipData) =&gt; { callback({code: zipErr ? '' : zipData.toString('utf8'), map}); }); }); }); } /** * G-zips the program if necessary and writes the results to disk. * * Skips the final write if the contents of the file have not changed since the previous write. * Which adds a little overhead at compile time, but at the same time does not alter the last modified timestamp of * the file unnecessarily. * * Good news for someone who is using that timestamp for public cache invalidation. * * @memberOf Compiler * @instance * @protected * @method save * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {ProgramData} data - processed application code with source maps * @param {Function} callback - a callback function * @example * compiler.save('/path/to/an/input/file', '/path/to/the/output/file', data, callback); */ save(inPath: string, outPath: string, data: ProgramData, callback: () =&gt; void) { this.fsRead(outPath, oldData =&gt; { const newData = { code: oldData.code === data.code ? '' : data.code, map: oldData.map === data.map ? '' : data.map }; if (!this.compress) { Compiler.writeAndCallDone(inPath, outPath, newData, callback); return; } Compiler.gzip(newData, result =&gt; { Compiler.writeAndCallDone(inPath, outPath, result, callback); }); }); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"DevServer.js.html":{"id":"DevServer.js.html","title":"Source: DevServer.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: DevServer.js /* @flow */ import type {DevServerConfig} from './typedef'; import {SASSCompiler} from './SASSCompiler'; import {watch} from './watch'; import tinylr from 'tiny-lr'; import WebpackDevServer from 'webpack-dev-server'; import webpack from 'webpack'; import {join} from 'path'; const LIVERELOAD_PORT = 35729, WEB_PORT = 3000, cwd = process.cwd(), {HotModuleReplacementPlugin, NoErrorsPlugin} = webpack, defaultOptions = { port: WEB_PORT, react: true, contentBase: cwd }; /** * A lightweight development server that rapidly recompiles the JavaScript and SASS files when they are edited and * updates the page. * * Utilizes the Webpack development server. * * Includes react hot loader to further optimize the development process of the React applications. * * Please install and enable the LiveReload browser extension for the CSS reloading to work. * * @class DevServer * @param {string} script - a full system path to a JavaScript file * @param {DevServerConfig} [options={}] - optional configuration * @see {@link http://webpack.github.io/docs/webpack-dev-server.html webpack-dev-server} * @see {@link http://gaearon.github.io/react-hot-loader/ React Hot Loader} * @example * import {DevServer} from 'webcompiler'; * // or - import {DevServer} from 'webcompiler/lib/DevServer'; * // or - var DevServer = require('webcompiler').DevServer; * // or - var DevServer = require('webcompiler/lib/DevServer').DevServer; * import {join} from 'path'; * * const devDir = join(__dirname, '..', 'development'), * script = join(devDir, 'script.js'), * style = join(devDir, 'app.scss'); * * new DevServer(script, {style}).run(); * // now navigate to http://localhost:3000 using your favorite browser ( preferably Chrome :) ) */ export class DevServer { /** * a full system path to a JavaScript file * * @member {string} script * @memberof DevServer * @private * @instance */ script: string; /** * optional configuration * * @member {Object} options * @memberof DevServer * @private * @instance */ options: Object; /* eslint-disable require-jsdoc */ constructor(script: string, options: DevServerConfig = {}) { /* eslint-enable require-jsdoc */ this.script = script; this.options = {...defaultOptions, ...options}; } /** * Returns the HTML page layout * * @memberof DevServer * @private * @instance * @method layout * @return {string} HTML layout */ layout(): string { return `&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Development server - WebCompiler&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot;&gt;${ this.options.style ? '\\n &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;' : '' } &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/script.js&quot; async defer&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`; } /** * Returns the JavaScript module loaders array necessary to run the server * * @memberof DevServer * @private * @instance * @method loaders * @return {Array&lt;string&gt;} JavaScript module loaders */ loaders(): Array&lt;string&gt; { const loaders = []; if (this.options.react) { loaders.push('react-hot'); } loaders.push('babel'); return loaders; } /** * Compile SASS and start watching for file changes * * @memberof DevServer * @instance * @method watchSASS * @example * server.watchSASS(); */ watchSASS() { const {style, contentBase} = this.options; if (!style) { return; } const sass = new SASSCompiler(false), lr = tinylr(), compileSASS = sass.fe.bind(sass, style, join(contentBase, 'style.css'), () =&gt; { lr.changed({body: {files: ['style.css']}}); }); lr.listen(LIVERELOAD_PORT); compileSASS(); watch(cwd, 'scss', compileSASS); } /** * Starts the Webpack development server * * @memberof DevServer * @instance * @method watchJS * @example * server.watchJS(); */ watchJS() { const {port, contentBase} = this.options; const server = new WebpackDevServer(webpack({ cache: {}, debug: true, devtool: 'eval-source-map', entry: [ `webpack-dev-server/client?http://localhost:${port}`, 'webpack/hot/only-dev-server', this.script ], output: { path: contentBase, filename: 'script.js', publicPath: '/' }, plugins: [new HotModuleReplacementPlugin(), new NoErrorsPlugin()], module: { loaders: [{ test: /\\.js$/, exclude: /node_modules/, loaders: this.loaders() }, { test: /\\.json$/, loader: 'json' }] } }), { contentBase, publicPath: '/', hot: true, historyApiFallback: true }); server.app.use((req, res) =&gt; { res.send(this.layout()); }); server.listen(port, '0.0.0.0', error =&gt; { if (error) { return console.error(error); } console.log('\\x1b[32mStarted the development server at localhost:%d\\x1b[0m', port); }); } /** * Starts the Webpack development server, compiles SASS and starts watching for file changes * * @memberof DevServer * @instance * @method run * @example * server.run(); */ run() { this.watchJS(); this.watchSASS(); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"typedef.js.html":{"id":"typedef.js.html","title":"Source: typedef.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: typedef.js /* @flow */ /** * Processed application code with source maps * * @typedef {Object} ProgramData * @property {string} code - program code * @property {string} map - source map json string */ export type ProgramData = { code: string; map: string; }; /** * The JavaScript linting error object * * @typedef {Object} JSLintError * @property {string} message - the error message * @property {string} [ruleId] - the relative linting rule * @property {string} filePath - the path to a file * @property {number} line - the offending line number * @property {number} column - the offending column number */ export type JSLintError = { message: string; ruleId?: string; filePath: string; line: number; column: number; }; /** * DevServer configuration object * * @typedef {Object} DevServerConfig * @property {string} [style] - a full system path to a SASS file * @property {number} [port=3000] - a port at which to start the dev server * @property {boolean} [react=true] - false to disable the react hot loader plugin * @property {string} [contentBase=CWD] - a full system path to the server web root */ export type DevServerConfig = { style?: string; port?: number; react?: boolean; contentBase?: string; }; /** * Documentation generator configuration object * * @typedef {Object} DocumentationConfig * @property {string} [inputDir=&quot;src&quot;] - the input application code directory * @property {string} [outputDir=&quot;docs&quot;] - the output directory for the generated documentation * @property {string} [readMe=&quot;README.md&quot;] - the documentation &quot;homepage&quot; (README.md file) * @property {string} [template=&quot;node_modules/ink-docstrap/template&quot;] - a full system path to a valid JSDoc3 * template directory * @property {string} [jsdocConfig=&quot;&lt;webcompiler root&gt;/config/jsdoc.json&quot;] - a full system path to a JSDoc3 * configuration file */ /** * @callback ProgramDataCallback * @param {ProgramData} data - the program data */ export type ProgramDataCallback = (data: ProgramData) =&gt; void; /** * @callback JSLintCallback * @param {Array&lt;JSLintError&gt;} [errors] - a collection of error objects */ export type JSLintCallback = (errors: ?Array&lt;JSLintError&gt;) =&gt; void; /** * @callback NativeProcessCallback * @param {string} [stderr] - an error message * @param {string} stdout - the process output */ export type NativeProcessCallback = (stderr: ?string, stdout: string) =&gt; void; /** * @callback ObjectOrErrorCallback * @param {string} [error] - an error message * @param {Object} result - the resulting object */ export type ObjectOrErrorCallback = (error: ?string, result: Object) =&gt; void; /** * Describes a file a change in which was caught. * * @typedef {Object} WatchmanFile * @property {string} name - the relative path to a file * @property {number} size - file size in bytes * @property {boolean} exists - true if the file exists * @property {string} type - e.g. &quot;f&quot; */ export type WatchmanFile = { name: string; size: number; exists: boolean; type: string; }; /** * A watchman response object. * * @typedef {Object} WatchmanResponse * @property {string} root - the path to the directory being watched * @property {string} subscription - random subscription name * @property {Array&lt;WatchmanFile&gt;} files - an array of file descriptions */ export type WatchmanResponse = { root: string; subscription: string; files: Array&lt;WatchmanFile&gt;; }; /** * @callback WatchCallback * @param {WatchmanResponse} response - a watchman response object */ export type WatchCallback = (response: WatchmanResponse) =&gt; void; × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"Documentation.js.html":{"id":"Documentation.js.html","title":"Source: Documentation.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: Documentation.js /* @flow */ import {NativeProcess} from './NativeProcess'; import {stat} from 'fs'; import {join} from 'path'; import noop from 'lodash/noop'; const npm = new NativeProcess('npm'), cwd = process.cwd(), defaultOptions = { inputDir: join(cwd, 'src'), outputDir: join(cwd, 'docs'), readMe: join(cwd, 'README.md'), template: join(cwd, 'node_modules', 'ink-docstrap', 'template'), jsdocConfig: join(__dirname, '..', 'config', 'jsdoc.json') }; /** * Generates API documentation * * The default JSDoc plugin specified in `jsdocConfig` strips out all of the code from a file while retaining newlines * (unlike the built in `commentsOnly` plugin that ships with JSDoc3). * * That way: * 1. line numbers are preserved in the source view * 2. you don't need to use a pre-compiler, you will always see the same code as you wrote in the docs source view * 3. since JSDoc only sees comments you can use any code syntax you like - ES2015, ES7, JSX, it doesn't even have to be * JavaScript. * * The markdown plugin is also included by default. * * @class Documentation * @param {DocumentationConfig} [config={}] - a configuration object * @example * import {Documentation} from 'webcompiler'; * // or - import {Documentation} from 'webcompiler/lib/Documentation'; * // or - var Documentation = require('webcompiler').Documentation; * // or - var Documentation = require('webcompiler/lib/Documentation').Documentation; * * const docs = new Documentation(); */ export class Documentation { /** * JSDoc3 * * @member {NativeProcess} jsdoc * @memberof Documentation * @private * @instance */ jsdoc: ?NativeProcess; /** * documentation generator configuration object * * @member {DocumentationConfig} options * @memberof Documentation * @private * @instance */ options: Object; /* eslint-disable require-jsdoc */ constructor(options: Object = {}) { /* eslint-enable require-jsdoc */ this.options = {...defaultOptions, ...options}; } /** * Finds a path to the JSDoc3 executable * * @memberof Documentation * @static * @private * @method findExecutable * @param {Function} callback - a callback function * @example * Documentation.findExecutable(file =&gt; { * // the jsdoc file is found * }); */ static findExecutable(callback: Function) { Documentation.checkBin(localFile =&gt; { if (localFile) { return callback(localFile); } Documentation.checkBin(globalFile =&gt; { if (globalFile) { return callback(globalFile); } console.error('Failed to locate the jsdoc executable'); }, true); }); } /** * Checks the NPM bin directories to see if they contain a file named jsdoc * * @memberof Documentation * @static * @private * @method checkBin * @param {Function} callback - a callback function * @param {boolean} [globalPackage=false] - if true checks the global NPM bin directory (contains the npm executable * itself) * @example * Documentation.checkBin(file =&gt; { * if (file) { * // the jsdoc file is found * } * }); */ static checkBin(callback: Function, globalPackage: boolean = false) { const args = ['bin']; if (globalPackage) { args.push('-g'); } npm.run((stderr, stdout) =&gt; { if (stderr) { console.error(stderr); return callback(null); } const path = join(stdout.replace(/\\n$/, ''), 'jsdoc'); stat(path, err =&gt; { callback(err ? null : path); }); }, args); } /** * Generate the documentation * * @memberof Documentation * @instance * @method run * @param {Function} [callback=function () {}] - a callback function * @return {void} * @example * docs.run(() =&gt; { * // generated the API documentation * }); */ run(callback: () =&gt; void = noop) { if (this.jsdoc) { return this.doRun(this.jsdoc, callback); } Documentation.findExecutable(file =&gt; { this.jsdoc = new NativeProcess(file); this.doRun(this.jsdoc, callback); }); } /** * Given a JSDoc3 executable, generate the documentation * * @memberof Documentation * @instance * @private * @method doRun * @param {NativeProcess} jsdoc - JSDoc3 * @param {Function} callback - a callback function * @example * docs.doRun(jsdoc, () =&gt; { * // generated the API documentation * }); */ doRun(jsdoc: NativeProcess, callback: () =&gt; void) { const {inputDir, outputDir, readMe, template, jsdocConfig} = this.options; jsdoc.run(stderr =&gt; { if (stderr) { return console.error(stderr); } callback(); }, [inputDir, '-d', outputDir, '-R', readMe, '-c', jsdocConfig, '-t', template]); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"JS.js.html":{"id":"JS.js.html","title":"Source: JS.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: JS.js /* @flow */ import {JSCompiler} from './JSCompiler'; import {NativeProcess} from './NativeProcess'; import {JSLint} from './JSLint'; import forEach from 'lodash/forEach'; import noop from 'lodash/noop'; /** * JavaScript compilation tools * * @class JS * @param {boolean} [compress=true] - if true `Compiler#save` will gzip compress the data * @param {Object} [babelOptions={}] - allows to override the default Babel options * @param {Object} [lintRules={}] - allows to override the default linting rules * @example * import {JS} from 'webcompiler'; * // or - import {JS} from 'webcompiler/lib/JS'; * // or - var JS = require('webcompiler').JS; * // or - var JS = require('webcompiler/lib/JS').JS; * * const js = new JS(); */ export class JS { /** * JavaScript compiler * * @member {JSCompiler} compiler * @memberof JS * @instance */ compiler: JSCompiler; /** * flow static analyzer * * @member {NativeProcess} flow * @memberof JS * @private * @instance */ flow: NativeProcess; /** * JavaScript linter * * @member {JSLint} linter * @memberof JS * @private * @instance */ linter: JSLint; /* eslint-disable require-jsdoc */ constructor(compress: boolean = true, babelOptions: Object = {}, lintRules: Object = {}) { /* eslint-enable require-jsdoc */ this.compiler = new JSCompiler(compress, babelOptions); this.flow = new NativeProcess('flow'); this.linter = new JSLint(lintRules); } /** * Performs static analysis * * @memberof JS * @instance * @method typecheck * @param {Function} callback - a callback function, invoked only when successfully typechecked * @example * js.typecheck(() =&gt; { * // successfully typechecked * }); */ typecheck(callback: () =&gt; void) { this.flow.run((flowErr, stdout) =&gt; { if (flowErr) { return console.error(flowErr); } if (!JSON.parse(stdout).passed) { return this.flow.run(noop, [], {stdio: 'inherit'}); } callback(); }, ['--json']); } /** * Performs linting * * @memberof JS * @instance * @method lint * @param {Array&lt;string&gt;} paths - an array of paths to files/directories to lint * @param {Function} callback - a callback function, invoked only when successfully linted * @example * js.lint(['/path/to/the/input/file.js', '/lint/this/directory/too'], () =&gt; { * // successfully linted * }); */ lint(paths: Array&lt;string&gt;, callback: () =&gt; void) { this.linter.run(paths, linterErr =&gt; { if (!linterErr) { return callback(); } forEach(linterErr, e =&gt; { console.log( '\\x1b[41mESLint error\\x1b[0m &quot;\\x1b[33m%s%s\\x1b[0m&quot; in \\x1b[36m%s\\x1b[0m on \\x1b[35m%s:%s\\x1b[0m', e.message, e.ruleId ? ` (${e.ruleId})` : '', e.filePath, e.line, e.column); }); console.log('JavaScript linting errors: %s', linterErr.length); }); } /** * Performs static analysis and linting * * @memberof JS * @instance * @private * @method validate * @param {string} inPath - the input file (will also be linted) * @param {Array&lt;string&gt;} lintPaths - an array of paths to files/directories to lint * @param {Function} callback - a callback function, invoked only when successfully validated * @example * js.validate('/path/to/the/input/file.js', ['/lint/this/directory/too'], () =&gt; { * // successfully validated * }); */ validate(inPath: string, lintPaths: Array&lt;string&gt;, callback: () =&gt; void) { this.typecheck(() =&gt; { this.lint(lintPaths.concat([inPath]), callback); }); } /** * Wraps {@link JSCompiler#be} to add static analysis and linting * * @memberOf JS * @instance * @method be * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Array&lt;string&gt;} [lintPaths=[]] - an array of paths to files/directories to lint * @param {Function} [callback=function () {}] - a callback function * @return {void} * @example * compiler.be('/path/to/an/input/file.js', '/path/to/the/output/file.js', ['/lint/this/directory/too'], () =&gt; { * // the code has passed all the checks and has been compiled successfully * }); */ be(inPath: string, outPath: string, lintPaths: Array&lt;string&gt; = [], callback: () =&gt; void = noop) { this.validate(inPath, lintPaths, () =&gt; { this.compiler.be(inPath, outPath, callback); }); } /** * Wraps {@link JSCompiler#fe} to add static analysis and linting * * @memberOf JS * @instance * @method fe * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Array&lt;string&gt;} [lintPaths=[]] - an array of paths to files/directories to lint * @param {Function} [callback=function () {}] - a callback function * @return {void} * @example * compiler.fe('/path/to/an/input/file.js', '/path/to/the/output/file.js', ['/lint/this/directory/too'], () =&gt; { * // the code has passed all the checks and has been compiled successfully * }); */ fe(inPath: string, outPath: string, lintPaths: Array&lt;string&gt; = [], callback: () =&gt; void = noop) { this.validate(inPath, lintPaths, () =&gt; { this.compiler.fe(inPath, outPath, callback); }); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"JSCompiler.js.html":{"id":"JSCompiler.js.html","title":"Source: JSCompiler.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: JSCompiler.js /* @flow */ import {Compiler} from './Compiler'; import {join, extname, dirname, basename} from 'path'; import {readdir, stat, createReadStream, createWriteStream, readFileSync} from 'fs'; import {transformFile} from 'babel-core'; import webpack from 'webpack'; import MemoryFS from 'memory-fs'; import forEach from 'lodash/forEach'; import noop from 'lodash/noop'; import assignWith from 'lodash/assignWith'; import get from 'lodash/get'; import isArray from 'lodash/isArray'; import uniq from 'lodash/uniq'; import map from 'lodash/map'; /* eslint-disable no-sync */ /* eslint-disable no-process-env */ const config = JSON.parse(readFileSync(join(__dirname, '..', '.babelrc'), 'utf8')), cache = {}, fakeFS = new MemoryFS(), {optimize, DefinePlugin} = webpack, {OccurrenceOrderPlugin, DedupePlugin, UglifyJsPlugin} = optimize, productionPlugins = [ new DefinePlugin({'process.env': {NODE_ENV: JSON.stringify('production')}}), new OccurrenceOrderPlugin(), new DedupePlugin(), new UglifyJsPlugin({compress: {warnings: false}}) ]; /** * A JavaScript compiler * * @class JSCompiler * @extends Compiler * @param {boolean} [compress=true] - if true `Compiler#save` will gzip compress the data * @param {Object} [options={}] - allows to override the default Babel options * @example * import {JSCompiler} from 'webcompiler'; * // or - import {JSCompiler} from 'webcompiler/lib/JSCompiler'; * // or - var JSCompiler = require('webcompiler').JSCompiler; * // or - var JSCompiler = require('webcompiler/lib/JSCompiler').JSCompiler; * * const compiler = new JSCompiler(); */ export class JSCompiler extends Compiler { /** * Babel options * * @member {Object} options * @memberOf JSCompiler * @private * @instance */ options: Object; /** * The number of files being compiled at the moment * * @member {number} processing * @memberOf JSCompiler * @private * @instance */ processing: number; /* eslint-disable require-jsdoc */ constructor(compress: boolean = true, options: Object = {}) { /* eslint-enable require-jsdoc */ super(compress); this.configure(options); this.processing = 0; } /** * Merges Babel configuration options * * @memberOf JSCompiler * @instance * @private * @method configure * @param {Object} options - allows to override the default Babel options * @example * compiler.configure(options); */ configure(options: Object) { this.options = assignWith({}, config, get(config, ['env', process.env.NODE_ENV || 'development']), options, (objValue, srcValue) =&gt; { if (!isArray(srcValue)) { return srcValue; } if (!isArray(objValue)) { return uniq(srcValue); } return uniq(srcValue.concat(objValue)); }); delete this.options.env; } /** * Compiles a directory of files for the back end * * @memberOf JSCompiler * @instance * @private * @method beDir * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Function} callback - a callback function * @example * compiler.beDir('/path/to/an/input/directory', '/path/to/the/output/directory', callback); */ beDir(inPath: string, outPath: string, callback: () =&gt; void) { readdir(inPath, (readdirErr, files) =&gt; { if (readdirErr) { return console.error(readdirErr); } forEach(files, file =&gt; { this.beTraverse(join(inPath, file), join(outPath, file), callback); }); }); } /** * Compiles a JavaScript file for the back end * * @memberOf JSCompiler * @instance * @private * @method beFile * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Function} callback - a callback function * @example * compiler.beFile('/path/to/an/input/file.js', '/path/to/the/output/file.js', callback); */ beFile(inPath: string, outPath: string, callback: () =&gt; void) { ++this.processing; transformFile(inPath, this.options, (transformFileErr, result) =&gt; { if (transformFileErr) { return console.error(transformFileErr); } Compiler.fsWrite(outPath, result, callback); }); } /** * Copies a file * * @memberOf JSCompiler * @instance * @private * @method copyFile * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Function} callback - a callback function * @example * compiler.copyFile('/path/to/an/input/file', '/path/to/the/output/file', callback); */ copyFile(inPath: string, outPath: string, callback: () =&gt; void) { ++this.processing; Compiler.mkdir(outPath, () =&gt; { createReadStream(inPath).pipe(createWriteStream(outPath)); callback(); }); } /** * Compiles a JavaScript file for the back end or recursively traverses a directory, looking for the JavaScript files * to compile. Non-JavaScript files are simply copied over. * * @memberOf JSCompiler * @instance * @private * @method beTraverse * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Function} callback - a callback function * @example * compiler.beTraverse('/path/to/an/input/file.js', '/path/to/the/output/file.js', callback); */ beTraverse(inPath: string, outPath: string, callback: () =&gt; void) { stat(inPath, (statErr, stats) =&gt; { if (statErr) { return console.error(statErr); } if (stats.isDirectory()) { this.beDir(inPath, outPath, callback); } else if ('.js' === extname(inPath)) { this.beFile(inPath, outPath, callback); } else { this.copyFile(inPath, outPath, callback); } }); } /** * Compiles a JavaScript file or a directory for the back end. Non-JavaScript files are simply copied over. * * @memberOf JSCompiler * @instance * @method be * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Function} [callback=function () {}] - a callback function * @return {void} * @example * compiler.be('/path/to/an/input/file.js', '/path/to/the/output/file.js', callback); */ be(inPath: string, outPath: string, callback: () =&gt; void = noop) { if (this.processing) { return console.error('Still working...'); } this.beTraverse(inPath, outPath, () =&gt; { --this.processing; if (!this.processing) { Compiler.done(inPath, callback); } }); } /** * Compiles, bundles (in production mode also minifies and g-zips) a JavaScript file for the front end. * * @memberOf JSCompiler * @instance * @method fe * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Function} [callback=function () {}] - a callback function * @example * compiler.fe('/path/to/an/input/file.js', '/path/to/the/output/file.js', callback); */ fe(inPath: string, outPath: string, callback: () =&gt; void = noop) { const {presets, ...options} = this.options, compiler = webpack({ cache, debug: true, devtool: 'source-map', entry: inPath, output: {path: dirname(outPath), filename: basename(outPath)}, plugins: this.isProduction ? productionPlugins : [], node: { fs: 'empty' }, module: { loaders: [{ test: /jsdom/, loader: 'null' }, { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: { cacheDirectory: true, presets: map(presets, preset =&gt; { if ('es2015' === preset) { return 'es2015-native-modules'; } if ('es2015-loose' === preset) { return 'es2015-loose-native-modules'; } return preset; }), ...options } }, { test: /\\.json$/, loader: 'json' }] } }); compiler.outputFileSystem = fakeFS; compiler.run((err, stats) =&gt; { if (err) { return console.error(err); } const {warnings, errors} = stats.toJson(); forEach(warnings, warning =&gt; { console.log('\\x1b[33m%s\\x1b[0m', warning); }); if (errors.length) { return forEach(errors, error =&gt; { console.error(error); }); } this.save(inPath, outPath, { code: fakeFS.readFileSync(outPath, 'utf8'), map: fakeFS.readFileSync(`${outPath}.map`, 'utf8') }, callback); }); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"JSLint.js.html":{"id":"JSLint.js.html","title":"Source: JSLint.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: JSLint.js /* @flow */ import type {JSLintCallback} from './typedef'; import {CLIEngine} from 'eslint'; import {join} from 'path'; import forEach from 'lodash/forEach'; const configFile = join(__dirname, '..', '.eslintrc.yml'); /** * A JavaScript linter * * @class JSLint * @param {Object} [rules={}] - an object that lets you override default linting rules * @example * import {JSLint} from 'webcompiler'; * // or - import {JSLint} from 'webcompiler/lib/JSLint'; * // or - var JSLint = require('webcompiler').JSLint; * // or - var JSLint = require('webcompiler/lib/JSLint').JSLint; * import {join} from 'path'; * * const linter = new JSLint(); */ export class JSLint { /** * an internal linter instance * * @member {CLIEngine} linter * @memberof JSLint * @private * @instance */ linter: CLIEngine; /* eslint-disable require-jsdoc */ constructor(rules: Object = {}) { /* eslint-enable require-jsdoc */ this.linter = new CLIEngine({configFile, rules}); } /** * Execute the linter * * @memberof JSLint * @instance * @method run * @param {Array&lt;string&gt;} paths - an array of paths to files/directories to lint * @param {JSLintCallback} callback - a callback function, accepts 1 argument: an array of error objects or null * @example * // lint &quot;index.js&quot; as well as the entire contents of the &quot;src&quot; directory * linter.run([join(__dirname, 'index.js'), join(__dirname, 'src')], function (err) { * if (err) { * return e.forEach(e =&gt; { * console.log('\\x1b[41mESLint error\\x1b[0m &quot;\\x1b[33m%s%s\\x1b[0m&quot; in \\x1b[36m%s\\x1b[0m on \\x1b[35m%s:%s\\x1b[0m', * e.message, e.ruleId ? ` (${e.ruleId})` : '', e.filePath, e.line, e.column); * }); * } * // there were no linting errors * }); */ run(paths: Array&lt;string&gt;, callback: JSLintCallback) { const report = this.linter.executeOnFiles(paths), errors = []; forEach(report.results, f =&gt; { forEach(f.messages, e =&gt; { e.filePath = f.filePath; errors.push(e); }); }); callback(errors.length ? errors : null); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"highlight.js.html":{"id":"highlight.js.html","title":"Source: highlight.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: highlight.js /* @flow */ import {jsdom} from 'jsdom'; import noop from 'lodash/noop'; import constant from 'lodash/constant'; import {load} from 'cheerio'; import {transformElements, arrayToJSX} from './jsx'; /** * CodeMirror syntax highlighting that works in the browser and on Node.js * * @module highlight */ // when not in the browser, polyfill specific DOM requirements of CodeMirror if ('undefined' === typeof navigator) { global.window = jsdom().defaultView; global.navigator = window.navigator; window.document.createRange = constant({setEnd: noop, setStart: noop, getBoundingClientRect: constant({})}); global.document = window.document; } // we have to use normal requires because of the import hoisting const cm = require('codemirror'); require('codemirror/mode/jsx/jsx'); /** * Using the CodeMirror editor highlights a string of text representing JavaScript program code. * * @memberof module:highlight * @private * @method highlight * @param {string} value - any valid ES2015, TypeScript, JSX, Flow code * @return {Object} an object containing a CheerioDOM object and a CheerioCollection of the `pre.CodeMirror-line` * elements */ export function highlight(value: string): {dom: any; lines: any} { const el = document.createElement('div'); cm(el, {value, mode: {name: 'jsx', typescript: true}, scrollbarStyle: 'null', inputStyle: 'contenteditable'}); const dom = load(el.innerHTML), lines = dom('.CodeMirror-line'); /* eslint-disable lodash/prefer-lodash-method */ lines.find('&gt; span').removeAttr('style'); /* eslint-enable lodash/prefer-lodash-method */ return {dom, lines}; } /** * Using the CodeMirror editor highlights a string of text representing JavaScript program code and returns an HTML * string. * * @memberof module:highlight * @method highlightHTML * @param {string} [code=&quot;&quot;] - any valid ES2015, TypeScript, JSX, Flow code * @return {string} an HTML string of the `pre.CodeMirror-line` elements * @example * import {highlightHTML} from 'webcompiler'; * // or - import {highlightHTML} from 'webcompiler/lib/highlight'; * // or - var highlightHTML = require('webcompiler').highlightHTML; * // or - var highlightHTML = require('webcompiler/lib/highlight').highlightHTML; * * highlightHTML('function myScript(){return 100;}'); // &lt;pre class=&quot;CodeMirror-line&quot;&gt;...&lt;/pre&gt; */ export function highlightHTML(code: string = ''): string { if (!code) { return ''; } const {dom, lines} = highlight(code); return dom.html(lines); } /** * Using the CodeMirror editor highlights a string of text representing JavaScript program code and returns an array of * plain objects describing React Elements for easy serialization/unserialization. * * @memberof module:highlight * @method highlightArray * @param {string} [code=&quot;&quot;] - any valid ES2015, TypeScript, JSX, Flow code * @return {Array&lt;string|Object&gt;} an array of plain objects describing React Elements * @example * import {highlightArray} from 'webcompiler'; * // or - import {highlightArray} from 'webcompiler/lib/highlight'; * // or - var highlightArray = require('webcompiler').highlightArray; * // or - var highlightArray = require('webcompiler/lib/highlight').highlightArray; * * highlightArray('function myScript(){return 100;}'); * // [{type: 'pre', props: {className: 'CodeMirror-line'}, children: [...]}] */ export function highlightArray(code: string = ''): Array&lt;string|Object&gt; { if (!code) { return []; } const {lines} = highlight(code); return transformElements(lines.toArray()); } /** * Using the CodeMirror editor highlights a string of text representing JavaScript program code and returns an array * of React elements. * * @memberof module:highlight * @method highlightJSX * @param {string} [code=&quot;&quot;] - any valid ES2015, TypeScript, JSX, Flow code * @return {Array&lt;ReactElement&gt;} React elements of the `pre.CodeMirror-line` elements * @example * import {highlightJSX} from 'webcompiler'; * // or - import {highlightJSX} from 'webcompiler/lib/highlight'; * // or - var highlightJSX = require('webcompiler').highlightJSX; * // or - var highlightJSX = require('webcompiler/lib/highlight').highlightJSX; * * &lt;div className=&quot;CodeMirror cm-s-monokai&quot;&gt;{highlightJSX('function myScript(){return 100;}')}&lt;/div&gt; */ export function highlightJSX(code: string = ''): Array&lt;any&gt; { return arrayToJSX(highlightArray(code)); } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"jsx.js.html":{"id":"jsx.js.html","title":"Source: jsx.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: jsx.js /* @flow */ import {load} from 'cheerio'; import {createElement} from 'react'; import reject from 'lodash/reject'; import map from 'lodash/map'; import transform from 'lodash/transform'; import has from 'lodash/has'; import flattenDeep from 'lodash/flattenDeep'; import isString from 'lodash/isString'; import trim from 'lodash/trim'; /** * Useful utilities for working with JSX. * * @module jsx */ /** * Parses an HTML string. * * @memberof module:jsx * @private * @method parseHTML * @param {string} html - an arbitrary HTML string * @return {Object} an object containing a CheerioDOM object and a CheerioCollection of the `pre.CodeMirror-line` * elements */ export function parseHTML(html: string): Object { const dom = load(html), {children} = dom.root().toArray()[0]; return {dom, children}; } /** * Convert the CSS style key to a JSX style key. * * @memberof module:jsx * @private * @method toJSXKey * @param {string} key - CSS style key * @return {string} JSX style key */ export function toJSXKey(key: string): string { return (/^-ms-/.test(key) ? key.substr(1) : key).replace(/-(.)/g, (match, chr) =&gt; chr.toUpperCase()); } /** * Parse the specified inline style attribute value. * * @memberof module:jsx * @private * @method transformStyle * @param {Object} object - the object to perform replacements on */ export function transformStyle(object: Object) { if (has(object, 'style')) { object.style = transform(object.style.split(';'), (result, style) =&gt; { const firstColon = style.indexOf(':'), key = style.substr(0, firstColon).trim(); if (key) { result[toJSXKey(key.toLowerCase())] = style.substr(firstColon + 1).trim(); } }, {}); } } /** * Renames specified attributes if present. * * @memberof module:jsx * @private * @method rename * @param {Object} object - the object to perform replacements on * @param {string} fromKey - a key to look for * @param {string} toKey - a key to rename to */ export function rename(object: Object, fromKey: string, toKey: string) { if (has(object, fromKey)) { object[toKey] = object[fromKey]; delete object[fromKey]; } } /** * Converts a Cheerio Element into an object that can later be used to create a React Element. * * @memberof module:jsx * @private * @method transformElement * @param {Object} element - a Cheerio Element * @return {Object} a plain object describing a React Element */ export function transformElement(element: Object): Object { const {name, attribs, children} = element; transformStyle(attribs); rename(attribs, 'for', 'htmlFor'); rename(attribs, 'class', 'className'); if ('input' === name) { rename(attribs, 'checked', 'defaultChecked'); rename(attribs, 'value', 'defaultValue'); } let childElements = transformElements(children); if ('textarea' === name &amp;&amp; childElements.length) { attribs.defaultValue = childElements[0]; childElements = []; } return {type: name, props: attribs, children: childElements}; } /** * Converts an array of Cheerio Elements to an array of plain objects describing React Elements for easy * serialization/unserialization. * * @memberof module:jsx * @private * @method transformElements * @param {Array&lt;Object&gt;} [elements=[]] - Cheerio Elements * @return {Array&lt;string|Object&gt;} an array of plain objects describing React Elements */ export function transformElements(elements: Array&lt;Object&gt; = []): Array&lt;string|Object&gt; { return map(reject(elements, ['type', 'comment']), el =&gt; 'text' === el.type ? el.data : transformElement(el)); } /** * Recursively flattens `args`, removes falsy values and combines string values. * * Can be used as a simple optimization step on the JSX children-to-be to simplify the resulting DOM structure by * joining adjacent text nodes together. * * @memberof module:jsx * @method flatten * @param {...*} args - the input values * @return {Array&lt;*&gt;} the flattened result * @example * import {flatten} from 'webcompiler'; * // or - import {flatten} from 'webcompiler/lib/jsx'; * // or - var flatten = require('webcompiler').flatten; * // or - var flatten = require('webcompiler/lib/jsx').flatten; * * flatten('lorem ', ['ipsum ', null, ['dolor ', ['sit ', ['amet']]]]); // [&quot;lorem ipsum dolor sit amet&quot;] */ export function flatten(...args: Array&lt;any&gt;): Array&lt;any&gt; { return transform(flattenDeep(args), (accumulator, value) =&gt; { if (!value) { return; } const lastIndex = accumulator.length - 1; if (isString(value) &amp;&amp; isString(accumulator[lastIndex])) { accumulator[lastIndex] += value; } else { accumulator.push(value); } }, []); } /** * Converts an array of plain objects describing React Elements to an array of React Elements. * * @memberof module:jsx * @method arrayToJSX * @param {Array&lt;string|Object&gt;} [arr=[]] - an array of plain objects describing React Elements * @return {Array&lt;ReactElement&gt;} an array of React Elements * @example * import {arrayToJSX} from 'webcompiler'; * // or - import {arrayToJSX} from 'webcompiler/lib/jsx'; * // or - var arrayToJSX = require('webcompiler').arrayToJSX; * // or - var arrayToJSX = require('webcompiler/lib/jsx').arrayToJSX; * * &lt;div&gt;{arrayToJSX([{type: 'h1', children: ['Hello world!']}])}&lt;/div&gt; */ export function arrayToJSX(arr: Array&lt;string|Object&gt; = []): Array&lt;any&gt; { return map(arr, (el, key: number) =&gt; { if (isString(el)) { return el; } const {type, props, children} = el; return createElement(type, {...props, key}, ...arrayToJSX(children)); }); } /** * Converts an arbitrary HTML string to an array of plain objects describing React Elements for easy * serialization/unserialization. * * @memberof module:jsx * @method htmlToArray * @param {string} [html=&quot;&quot;] - an arbitrary HTML string * @return {Array&lt;string|Object&gt;} an array of plain objects describing React Elements * @example * import {htmlToArray} from 'webcompiler'; * // or - import {htmlToArray} from 'webcompiler/lib/jsx'; * // or - var htmlToArray = require('webcompiler').htmlToArray; * // or - var htmlToArray = require('webcompiler/lib/jsx').htmlToArray; * * htmlToArray('&lt;h1&gt;Hello world!&lt;/h1&gt;'); // [{type: 'h1', children: ['Hello world!']}] */ export function htmlToArray(html: string = ''): Array&lt;string|Object&gt; { html = trim(html); return html ? transformElements(parseHTML(html).children) : []; } /** * Converts an arbitrary HTML string to an array of React Elements. * * @memberof module:jsx * @method htmlToJSX * @param {string} [html=&quot;&quot;] - an arbitrary HTML string * @return {Array&lt;ReactElement&gt;} an array of React Elements * @example * import {htmlToJSX} from 'webcompiler'; * // or - import {htmlToJSX} from 'webcompiler/lib/jsx'; * // or - var htmlToJSX = require('webcompiler').htmlToJSX; * // or - var htmlToJSX = require('webcompiler/lib/jsx').htmlToJSX; * * &lt;div&gt;{htmlToJSX('&lt;h1&gt;Hello world!&lt;/h1&gt;')}&lt;/div&gt; */ export function htmlToJSX(html: string = ''): Array&lt;any&gt; { return arrayToJSX(htmlToArray(html)); } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"markdown.js.html":{"id":"markdown.js.html","title":"Source: markdown.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: markdown.js /* @flow */ import trim from 'lodash/trim'; import Remarkable from 'remarkable'; import {htmlToArray, parseHTML, htmlToJSX} from './jsx'; const md = new Remarkable('full', {html: true, linkify: true, typographer: true}); /** * Useful utilities for working with Markdown. * * @module markdown */ /** * If a simple single line string is passed to the Markdown parser it thinks that it's a paragraph (it sort of * technically is) and unnecessarily wraps it into `&lt;p&gt;&lt;/p&gt;`, which most often is not the desired behavior. * * This function converts Markdown to HTML and then removes the wrapping paragraph if it is the only top level tag * unwrapping its contents. * * @memberof module:markdown * @private * @method markdownToUnwrappedHTML * @param {string} markdown - an arbitrary Markdown string * @return {string} an HTML string */ export function markdownToUnwrappedHTML(markdown: string): string { const html = trim(md.render(markdown)), {dom, children} = parseHTML(html); if (1 !== children.length) { return html; } const child = children[0], {type, name} = child; return 'tag' === type &amp;&amp; 'p' === name ? dom(child).html() : html; } /** * Converts an arbitrary Markdown string to an array of plain objects describing React Elements for easy * serialization/unserialization. * * @memberof module:markdown * @method markdownToArray * @param {string} [markdown=&quot;&quot;] - an arbitrary Markdown string * @return {Array&lt;string|Object&gt;} an array of plain objects describing React Elements * @example * import {markdownToArray} from 'webcompiler'; * // or - import {markdownToArray} from 'webcompiler/lib/markdown'; * // or - var markdownToArray = require('webcompiler').markdownToArray; * // or - var markdownToArray = require('webcompiler/lib/markdown').markdownToArray; * * markdownToArray('# Hello world!'); // [{type: 'h1', children: ['Hello world!']}] */ export function markdownToArray(markdown: string = ''): Array&lt;string|Object&gt; { markdown = trim(markdown); return markdown ? htmlToArray(markdownToUnwrappedHTML(markdown)) : []; } /** * Converts an arbitrary Markdown string to an array of React Elements * * @memberof module:markdown * @method markdownToJSX * @param {string} [markdown=&quot;&quot;] - an arbitrary Markdown string * @return {Array&lt;ReactElement&gt;} an array of React Elements * @example * import {markdownToJSX} from 'webcompiler'; * // or - import {markdownToJSX} from 'webcompiler/lib/markdown'; * // or - var markdownToJSX = require('webcompiler').markdownToJSX; * // or - var markdownToJSX = require('webcompiler/lib/markdown').markdownToJSX; * * &lt;div&gt;{markdownToJSX('# Hello world!')}&lt;/div&gt; */ export function markdownToJSX(markdown: string = ''): Array&lt;any&gt; { markdown = trim(markdown); return markdown ? htmlToJSX(markdownToUnwrappedHTML(markdown)) : []; } /** * Converts an arbitrary Markdown string to an HTML string * * @memberof module:markdown * @method markdownToHTML * @param {string} [markdown=&quot;&quot;] - an arbitrary Markdown string * @return {string} an HTML string * @example * import {markdownToHTML} from 'webcompiler'; * // or - import {markdownToHTML} from 'webcompiler/lib/markdown'; * // or - var markdownToHTML = require('webcompiler').markdownToHTML; * // or - var markdownToHTML = require('webcompiler/lib/markdown').markdownToHTML; * * markdownToHTML('# Hello world!'); // &lt;h1&gt;Hello world!&lt;/h1&gt; */ export function markdownToHTML(markdown: string = ''): string { markdown = trim(markdown); return markdown ? markdownToUnwrappedHTML(markdown) : ''; } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"NativeProcess.js.html":{"id":"NativeProcess.js.html","title":"Source: NativeProcess.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: NativeProcess.js /* @flow */ import type {NativeProcessCallback} from './typedef'; import {spawn} from 'child_process'; import noop from 'lodash/noop'; /** * Encapsulates a {@link https://nodejs.org/api/child_process.html#child_process_class_childprocess ChildProcess} * instance of a `task` * * @class NativeProcess * @param {string} task - a process name * @example * import {NativeProcess} from 'webcompiler'; * // or - import {NativeProcess} from 'webcompiler/lib/NativeProcess'; * // or - var NativeProcess = require('webcompiler').NativeProcess; * // or - var NativeProcess = require('webcompiler/lib/NativeProcess').NativeProcess; * * const mkdir = new NativeProcess('mkdir'); */ export class NativeProcess { /** * a process name * * @member {string} task * @memberof NativeProcess * @private * @instance */ task: string; /** * a ChildProcess instance * * @member {ChildProcess} proc * @memberof NativeProcess * @private * @instance */ proc: any; /* eslint-disable require-jsdoc */ constructor(task: string) { /* eslint-enable require-jsdoc */ this.task = task; } /** * Execute the command * * @memberof NativeProcess * @instance * @method run * @param {NativeProcessCallback} [callback=function () {}] - a callback function * @param {Array&lt;string&gt;} [args=[]] - an array of arguments to pass to the process * @param {Object} [opts={}] - a configuration object for the process * @return {void} * @example * mkdir.run(error =&gt; { * if (error) { * return console.error(error); * } * // created a directory named &quot;example&quot; in cwd * }, ['example']); */ run(callback: NativeProcessCallback = noop, args: Array&lt;string&gt; = [], opts: Object = {}) { if (this.proc) { return callback('Still working...', ''); } this.proc = spawn(this.task, args, opts); let stdout = '', stderr = ''; if (this.proc.stdout) { this.proc.stdout.on('data', data =&gt; { stdout += data; }); } if (this.proc.stderr) { this.proc.stderr.on('data', data =&gt; { stderr += data; }); } this.proc.on('error', error =&gt; { stderr += error.toString(); }); this.proc.on('close', code =&gt; { this.proc = null; callback(code ? stderr : null, stdout); }); } /** * Kills the process if any is running * * @memberof NativeProcess * @instance * @method kill * @example * someEpensiveProcess.kill(); */ kill() { if (this.proc) { this.proc.kill(); this.proc = null; } } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"SASS.js.html":{"id":"SASS.js.html","title":"Source: SASS.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: SASS.js /* @flow */ import {SASSCompiler} from './SASSCompiler'; import {SASSLint} from './SASSLint'; import noop from 'lodash/noop'; /** * SASS compilation tools * * @class SASS * @param {boolean} [compress=true] - if true `Compiler#save` will gzip compress the data * @param {Array&lt;string&gt;} [includePaths=[]] - an array of additional include paths * @param {Array&lt;string&gt;} [excludeLinter=[]] - names of linters to exclude * @param {Object} [importOnceOptions={}] - an object that lets you override default importOnce resolver * configuration * @example * import {SASS} from 'webcompiler'; * // or - import {SASS} from 'webcompiler/lib/SASS'; * // or - var SASS = require('webcompiler').SASS; * // or - var SASS = require('webcompiler/lib/SASS').SASS; * * const sass = new SASS(); */ export class SASS { /** * SCSS compiler * * @member {SASSCompiler} compiler * @memberof SASS * @instance */ compiler: SASSCompiler; /** * SCSS linter * * @member {SASSLint} linter * @memberof SASS * @private * @instance */ linter: SASSLint; /* eslint-disable require-jsdoc */ constructor(compress: boolean = true, includePaths: Array&lt;string&gt; = [], excludeLinter: Array&lt;string&gt; = [], importOnceOptions: Object = {}) { /* eslint-enable require-jsdoc */ this.compiler = new SASSCompiler(compress, includePaths, importOnceOptions); this.linter = new SASSLint(...excludeLinter); } /** * Performs linting * * @memberof SASS * @instance * @method lint * @param {Array&lt;string&gt;} paths - an array of paths to lint * @param {Function} callback - a callback function * @example * sass.lint(['/path/to/the/input/file.scss', '/lint/this/directory/too'], () =&gt; { * // successfully linted * }); */ lint(paths: Array&lt;string&gt;, callback: () =&gt; void) { this.linter.run(paths, linterErr =&gt; { if (linterErr) { return console.error(linterErr); } callback(); }); } /** * Wraps {@link SASSCompiler#fe} to add linting * * @memberof SASS * @instance * @method fe * @param {string} inPath - the input path * @param {string} outPath - the output path * @param {Array&lt;string&gt;} [lintPaths=[]] - an array of paths to files/directories to lint * @param {Function} [callback=function () {}] - a callback function * @return {void} * @example * compiler.fe('/path/to/an/input/file.js', '/path/to/the/output/file.js', ['/lint/this/directory/too'], () =&gt; { * // the code has passed all the checks and has been compiled successfully * }); */ fe(inPath: string, outPath: string, lintPaths: Array&lt;string&gt; = [], callback: () =&gt; void = noop) { this.lint(lintPaths.concat([inPath]), () =&gt; { this.compiler.fe(inPath, outPath, callback); }); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"SASSCompiler.js.html":{"id":"SASSCompiler.js.html","title":"Source: SASSCompiler.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: SASSCompiler.js /* @flow */ import type {ProgramData, ProgramDataCallback} from './typedef'; import {Compiler} from './Compiler'; import {render} from 'node-sass'; import importer from 'node-sass-import-once'; import postcss from 'postcss'; import autoprefixer from 'autoprefixer'; import forEach from 'lodash/forEach'; import noop from 'lodash/noop'; const precision = 8, importOnceDefaults = {index: true, css: false, bower: false}, defaultIncludePaths = ['node_modules/bootstrap-sass/assets/stylesheets', 'node_modules', 'node_modules/bootswatch']; /** * A SASS compiler * * @class SASSCompiler * @extends Compiler * @param {boolean} [compress=true] - if true `Compiler#save` will gzip compress the data * @param {Array&lt;string&gt;} [includePaths=[]] - an array of additional include paths * @param {Object} [importOnceOptions={}] - an object that lets you override default importOnce resolver * configuration * @example * import {SASSCompiler} from 'webcompiler'; * // or - import {SASSCompiler} from 'webcompiler/lib/SASSCompiler'; * // or - var SASSCompiler = require('webcompiler').SASSCompiler; * // or - var SASSCompiler = require('webcompiler/lib/SASSCompiler').SASSCompiler; * * const compiler = new SASSCompiler(); */ export class SASSCompiler extends Compiler { /** * an array of paths to search for an scss file in if it's not found in cwd * * @member {Array&lt;string&gt;} includePaths * @memberof SASSCompiler * @private * @instance */ includePaths: Array&lt;string&gt;; /** * importOnce resolver configuration * * @member {Object} importOnce * @memberof SASSCompiler * @private * @instance */ importOnce: Object; /* eslint-disable require-jsdoc */ constructor(compress: boolean = true, includePaths: Array&lt;string&gt; = [], importOnceOptions: Object = {}) { /* eslint-enable require-jsdoc */ super(compress); this.includePaths = defaultIncludePaths.concat(includePaths); this.importOnce = {...importOnceDefaults, ...importOnceOptions}; } /** * Auto-prefixes the compiled code * * @memberOf SASSCompiler * @static * @method autoprefix * @param {string} path - a path to the file * @param {ProgramData} data - the actual program data to auto-prefix * @param {ProgramDataCallback} callback - a callback function * @example * SASSCompiler.autoprefix('/path/to/the/output/file.css', data, result =&gt; { * // successfully added the vendor prefixes * }); */ static autoprefix(path: string, data: ProgramData, callback: ProgramDataCallback) { postcss([autoprefixer]).process(data.code, { from: path, to: path, map: {prev: data.map} }).then(result =&gt; { const warnings = result.warnings(); if (warnings.length) { forEach(warnings, warning =&gt; { console.error(warning.toString()); }); return; } callback({code: result.css, map: JSON.stringify(result.map)}); }); } /** * Compiles, auto-prefixes and optionally minifies and g-zips in the production mode * * @memberof SASSCompiler * @instance * @method fe * @param {string} inPath - a full system path to the input file * @param {string} outPath - a full system path to the output file * @param {Function} [callback=function () {}] - a callback function * @example * compiler.fe('/path/to/the/input/file.scss', '/path/to/the/output/file.css', () =&gt; { * // compiled successfully * }); */ fe(inPath: string, outPath: string, callback: () =&gt; void = noop) { render({ file: inPath, outFile: outPath, importer, precision, importOnce: this.importOnce, includePaths: this.includePaths, sourceMap: true, sourceMapContents: true, outputStyle: this.isProduction ? 'compressed' : 'nested' }, (error, result) =&gt; { if (error) { return console.log( '\\x1b[41mSASS error\\x1b[0m &quot;\\x1b[33m%s\\x1b[0m&quot; in \\x1b[36m%s\\x1b[0m on \\x1b[35m%s:%s\\x1b[0m', error.message, error.file, error.line, error.column); } SASSCompiler.autoprefix(outPath, {code: result.css, map: result.map.toString()}, data =&gt; { this.save(inPath, outPath, data, callback); }); }); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"SASSLint.js.html":{"id":"SASSLint.js.html","title":"Source: SASSLint.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: SASSLint.js /* @flow */ import type {NativeProcessCallback} from './typedef'; import {NativeProcess} from './NativeProcess'; import {join} from 'path'; const config = join(__dirname, '..', 'config', 'scsslint.yml'); /** * A SASS linter * * @class SASSLint * @param {...string} excludeLinter - names of linters to exclude * @example * import {SASSLint} from 'webcompiler'; * // or - import {SASSLint} from 'webcompiler/lib/SASSLint'; * // or - var SASSLint = require('webcompiler').SASSLint; * // or - var SASSLint = require('webcompiler/lib/SASSLint').SASSLint; * import {join} from 'path'; * * const linter = new SASSLint(); */ export class SASSLint { /** * a comma-separated list of linter names to exclude from execution * * @member {string} excludeLinter * @memberof SASSLint * @private * @instance */ excludeLinter: string; /** * a NativeProcess instance for scss-lint * * @member {NativeProcess} proc * @memberof SASSLint * @private * @instance */ proc: NativeProcess; /** @constructs */ constructor(...excludeLinter: Array&lt;string&gt;) { this.excludeLinter = excludeLinter.join(','); this.proc = new NativeProcess('scss-lint'); } /** * Execute the linter * * @memberof SASSLint * @instance * @method run * @param {Array&lt;string&gt;} paths - an array of paths to files/directories to lint * @param {Function} callback - a callback function, accepts 1 argument: an error message or null * @example * // lint &quot;style.scss&quot; as well as the entire contents of the &quot;sass&quot; directory * linter.run([join(__dirname, 'style.scss'), join(__dirname, 'sass')], error =&gt; { * if (error) { * return console.error(error); * } * // there were no linting errors * }); */ run(paths: Array&lt;string&gt;, callback: NativeProcessCallback) { const args = paths.concat(['-c', config]); if (this.excludeLinter) { args.push('-x', this.excludeLinter); } this.proc.run(callback, args); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"watch.js.html":{"id":"watch.js.html","title":"Source: watch.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: watch.js /* @flow */ import type {WatchCallback} from './typedef'; import {Client} from 'fb-watchman'; const client = new Client(), ALPHANUMERIC_BASE = 36; /** * Using the Facebook Watchman, watches the directory `dir` for changes of files with extension `type` and runs * `callback` when a change is detected. * * This watcher's only goal is performance, hence the simplicity. * * @function watch * @param {string} dir - a full system path to a directory to watch * @param {string} type - a file extension * @param {WatchCallback} callback - a callback function * @see {@link https://facebook.github.io/watchman/ Watchman} * @example * import {watch} from 'webcompiler'; * // or - import {watch} from 'webcompiler/lib/watch'; * // or - var watch = require('webcompiler').watch; * // or - var watch = require('webcompiler/lib/watch').watch; * import {join} from 'path'; * * watch(join(__dirname, 'src'), 'js', someFunction); */ export function watch(dir: string, type: string, callback: WatchCallback) { const subscription = Date.now().toString(ALPHANUMERIC_BASE); client.capabilityCheck({}, capabilityErr =&gt; { if (capabilityErr) { console.error(capabilityErr); return; } client.command(['watch-project', dir], (watchErr, watchResp) =&gt; { const watcher = watchResp.watch; if (watchErr) { console.error('Error initiating watch:', watchErr); return; } if (watchResp.warning) { console.log('Warning:', watchResp.warning); } client.command(['clock', watcher], (clockErr, clockResp) =&gt; { if (clockErr) { console.error('Failed to query clock:', clockErr); return; } client.command(['subscribe', watcher, subscription, { expression: ['suffix', type], since: clockResp.clock }], subscribeErr =&gt; { if (subscribeErr) { console.error('Failed to subscribe:', subscribeErr); } }); client.on('subscription', subscriptionResp =&gt; { if (subscription === subscriptionResp.subscription) { callback(subscriptionResp); } }); }); }); }); } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"yaml.js.html":{"id":"yaml.js.html","title":"Source: yaml.js","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Source: yaml.js /* @flow */ import type {ObjectOrErrorCallback} from './typedef'; import {safeLoad} from 'js-yaml'; import {readFileSync} from 'fs'; /** * Read the contents of a YAML file * * @function yaml * @param {string} filename - the full system path to a YAML file * @param {ObjectOrErrorCallback} callback - a callback function * @example * import {yaml} from 'webcompiler'; * // or - import {yaml} from 'webcompiler/lib/yaml'; * // or - var yaml = require('webcompiler').yaml; * // or - var yaml = require('webcompiler/lib/yaml').yaml; * import {join} from 'path'; * * yaml(join(__dirname, 'config', 'config.yml'), (error, data) =&gt; { * if (error) { * return console.error(error); * } * // the parsed config object * }); */ export function yaml(filename: string, callback: ObjectOrErrorCallback) { try { const yamlString: string = readFileSync(filename, 'utf8'); callback(null, safeLoad(yamlString, {filename})); } catch (e) { callback(e.toString(), {}); } } × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Global Methods watch(dir, type, callback) Using the Facebook Watchman, watches the directory dir for changes of files with extension type and runs callback when a change is detected. This watcher's only goal is performance, hence the simplicity. Parameters: Name Type Description dir string a full system path to a directory to watch type string a file extension callback WatchCallback a callback function Source: watch.js, line 9 See: Watchman Example import {watch} from 'webcompiler'; // or - import {watch} from 'webcompiler/lib/watch'; // or - var watch = require('webcompiler').watch; // or - var watch = require('webcompiler/lib/watch').watch; import {join} from 'path'; watch(join(__dirname, 'src'), 'js', someFunction); yaml(filename, callback) Read the contents of a YAML file Parameters: Name Type Description filename string the full system path to a YAML file callback ObjectOrErrorCallback a callback function Source: yaml.js, line 7 Example import {yaml} from 'webcompiler'; // or - import {yaml} from 'webcompiler/lib/yaml'; // or - var yaml = require('webcompiler').yaml; // or - var yaml = require('webcompiler/lib/yaml').yaml; import {join} from 'path'; yaml(join(__dirname, 'config', 'config.yml'), (error, data) =&gt; { if (error) { return console.error(error); } // the parsed config object }); Type Definitions DevServerConfig DevServer configuration object Type: Object Properties: Name Type Argument Default Description style string &lt;optional&gt; a full system path to a SASS file port number &lt;optional&gt; 3000 a port at which to start the dev server react boolean &lt;optional&gt; true false to disable the react hot loader plugin contentBase string &lt;optional&gt; CWD a full system path to the server web root Source: typedef.js, line 33 DocumentationConfig Documentation generator configuration object Type: Object Properties: Name Type Argument Default Description inputDir string &lt;optional&gt; &quot;src&quot; the input application code directory outputDir string &lt;optional&gt; &quot;docs&quot; the output directory for the generated documentation readMe string &lt;optional&gt; &quot;README.md&quot; the documentation &quot;homepage&quot; (README.md file) template string &lt;optional&gt; &quot;node_modules/ink-docstrap/template&quot; a full system path to a valid JSDoc3 template directory jsdocConfig string &lt;optional&gt; &quot;&lt;webcompiler root&gt;/config/jsdoc.json&quot; a full system path to a JSDoc3 configuration file Source: typedef.js, line 49 JSLintCallback( [errors]) Parameters: Name Type Argument Description errors Array.&lt;JSLintError&gt; &lt;optional&gt; a collection of error objects Source: typedef.js, line 68 JSLintError The JavaScript linting error object Type: Object Properties: Name Type Argument Description message string the error message ruleId string &lt;optional&gt; the relative linting rule filePath string the path to a file line number the offending line number column number the offending column number Source: typedef.js, line 15 NativeProcessCallback( [stderr], stdout) Parameters: Name Type Argument Description stderr string &lt;optional&gt; an error message stdout string the process output Source: typedef.js, line 74 ObjectOrErrorCallback( [error], result) Parameters: Name Type Argument Description error string &lt;optional&gt; an error message result Object the resulting object Source: typedef.js, line 81 ProgramData Processed application code with source maps Type: Object Properties: Name Type Description code string program code map string source map json string Source: typedef.js, line 3 ProgramDataCallback(data) Parameters: Name Type Description data ProgramData the program data Source: typedef.js, line 62 WatchCallback(response) Parameters: Name Type Description response WatchmanResponse a watchman response object Source: typedef.js, line 118 WatchmanFile Describes a file a change in which was caught. Type: Object Properties: Name Type Description name string the relative path to a file size number file size in bytes exists boolean true if the file exists type string e.g. &quot;f&quot; Source: typedef.js, line 88 WatchmanResponse A watchman response object. Type: Object Properties: Name Type Description root string the path to the directory being watched subscription string random subscription name files Array.&lt;WatchmanFile&gt; an array of file descriptions Source: typedef.js, line 104 × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Modules Classes Compiler DevServer Documentation JS JSCompiler JSLint NativeProcess SASS SASSCompiler SASSLint × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Classes Classes Compiler DevServer Documentation JS JSCompiler JSLint NativeProcess SASS SASSCompiler SASSLint × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml webcompilerLint, type-check, compile, package and gzip JavaScript (ES6 + Flow static types + JSX), for the browser as well as NodeJS; lint, compile, auto-prefix, minify and gzip SASS. Project Home | API Docs | Discord Webpack is an amazing tool, however it requires a lot of boilerplate to properly setup and configure, especially when you use it on more than one project. ESLint is constantly updated, new rules are added, APIs are changed. Properly configuring it is a routine and time consuming task, which is completely impractical to perform on each project separately. APIs are sometimes changed without any change in functionality (e.g. Babel 5 vs Babel 6). This project aims to abstract all of those problems out of the development of applications. Prerequisites Facebook Flow SCSS-Lint Watchman A note about Facebook FlowFacebook Flow is a static analysis tool used to check your JavaScript code for possible errors at compile time. It is very smart at understanding your program code, however you should not rely on it being smart enough to just understand your external dependencies too. It can do that, the problem is that a typical NodeJS project can contain hundreds of NPM modules, with thousands of JavaScript files. It is a very complicated task, even for a tool that smart, to parse all of them and stay performant enough to not only be usable but useful as well. Which is why it must not be allowed to even try to understand any files that reside in a node_modules directory. Interface Files must be used instead. You can find examples of such interface files, as well as the interface file for the tool itself, in the interfaces directory. Installationnpm i webcompiler --save-devProduction buildsBy default all compilation is done in development mode. If you wish to compile for production just set the NODE_ENV environment variable to &quot;production&quot;, the following additional actions will be performed by the compiler: advanced compilation time optimizations minification (only fe in production mode) g-zip compression (only fe in production mode) Important!The resulting JavaScript and CSS files from fe in production mode are gzip compressed for performance (see Gzip Components), so make sure to provide a &quot;Content-Encoding&quot; header to the browser (e.g. res.setHeader('Content-Encoding', 'gzip');). × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"Compiler.html":{"id":"Compiler.html","title":"Class: Compiler","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: Compiler Compiler &lt;abstract&gt; new Compiler( [compress]) The base compiler class Parameters: Name Type Argument Default Description compress boolean &lt;optional&gt; true if true Compiler#save will gzip compress the data in production mode Source: Compiler.js, line 13 Members &lt;readonly&gt; isProduction :boolean True if the NODE_ENV environment variable is equal to production. Caution: modifying it's value directly may lead to unexpected results Type: boolean Source: Compiler.js, line 21 Methods &lt;static&gt; done(inPath, callback) Executed when the compilation is complete Parameters: Name Type Description inPath string the input path callback function a callback function Source: Compiler.js, line 50 Example Compiler.done('/path/to/an/input/file', callback); &lt;static&gt; fsWrite(path, data, callback) Writes the data to disk Parameters: Name Type Description path string the output path data ProgramData the data to write callback function a callback function Source: Compiler.js, line 90 Example Compiler.fsWrite('/path/to/an/output/file', data, callback); &lt;static&gt; gzip(data, callback) G-zips the compiled code Parameters: Name Type Description data ProgramData the actual program data to auto-prefix callback ProgramDataCallback a callback function Source: Compiler.js, line 141 Returns: Type void Example Compiler.gzip(data, callback); &lt;static&gt; mkdir(path, callback) Recursively creates a directory containing a file specified by path. Parameters: Name Type Description path string a path to a file callback function a callback function Source: Compiler.js, line 121 Example Compiler.mkdir('/path/to/a/file', callback); &lt;protected&gt; save(inPath, outPath, data, callback) G-zips the program if necessary and writes the results to disk. Skips the final write if the contents of the file have not changed since the previous write. Which adds a little overhead at compile time, but at the same time does not alter the last modified timestamp of the file unnecessarily. Good news for someone who is using that timestamp for public cache invalidation. Parameters: Name Type Description inPath string the input path outPath string the output path data ProgramData processed application code with source maps callback function a callback function Source: Compiler.js, line 198 Example compiler.save('/path/to/an/input/file', '/path/to/the/output/file', data, callback); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"DevServer.html":{"id":"DevServer.html","title":"Class: DevServer","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: DevServer DevServer new DevServer(script [, options]) A lightweight development server that rapidly recompiles the JavaScript and SASS files when they are edited and updates the page. Utilizes the Webpack development server. Includes react hot loader to further optimize the development process of the React applications. Please install and enable the LiveReload browser extension for the CSS reloading to work. Parameters: Name Type Argument Default Description script string a full system path to a JavaScript file options DevServerConfig &lt;optional&gt; {} optional configuration Source: DevServer.js, line 21 See: webpack-dev-server React Hot Loader Example import {DevServer} from 'webcompiler'; // or - import {DevServer} from 'webcompiler/lib/DevServer'; // or - var DevServer = require('webcompiler').DevServer; // or - var DevServer = require('webcompiler/lib/DevServer').DevServer; import {join} from 'path'; const devDir = join(__dirname, '..', 'development'), script = join(devDir, 'script.js'), style = join(devDir, 'app.scss'); new DevServer(script, {style}).run(); // now navigate to http://localhost:3000 using your favorite browser ( preferably Chrome :) ) Methods run() Starts the Webpack development server, compiles SASS and starts watching for file changes Source: DevServer.js, line 211 Example server.run(); watchJS() Starts the Webpack development server Source: DevServer.js, line 155 Example server.watchJS(); watchSASS() Compile SASS and start watching for file changes Source: DevServer.js, line 128 Example server.watchSASS(); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"Documentation.html":{"id":"Documentation.html","title":"Class: Documentation","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: Documentation Documentation new Documentation( [config]) Generates API documentation The default JSDoc plugin specified in jsdocConfig strips out all of the code from a file while retaining newlines (unlike the built in commentsOnly plugin that ships with JSDoc3). That way: line numbers are preserved in the source view you don't need to use a pre-compiler, you will always see the same code as you wrote in the docs source view since JSDoc only sees comments you can use any code syntax you like - ES2015, ES7, JSX, it doesn't even have to be JavaScript. The markdown plugin is also included by default. Parameters: Name Type Argument Default Description config DocumentationConfig &lt;optional&gt; {} a configuration object Source: Documentation.js, line 18 Example import {Documentation} from 'webcompiler'; // or - import {Documentation} from 'webcompiler/lib/Documentation'; // or - var Documentation = require('webcompiler').Documentation; // or - var Documentation = require('webcompiler/lib/Documentation').Documentation; const docs = new Documentation(); Methods run( [callback]) Generate the documentation Parameters: Name Type Argument Default Description callback function &lt;optional&gt; function () {} a callback function Source: Documentation.js, line 133 Returns: Type void Example docs.run(() =&gt; { // generated the API documentation }); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"JS.html":{"id":"JS.html","title":"Class: JS","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: JS JS new JS( [compress] [, babelOptions] [, lintRules]) JavaScript compilation tools Parameters: Name Type Argument Default Description compress boolean &lt;optional&gt; true if true Compiler#save will gzip compress the data babelOptions Object &lt;optional&gt; {} allows to override the default Babel options lintRules Object &lt;optional&gt; {} allows to override the default linting rules Source: JS.js, line 9 Example import {JS} from 'webcompiler'; // or - import {JS} from 'webcompiler/lib/JS'; // or - var JS = require('webcompiler').JS; // or - var JS = require('webcompiler/lib/JS').JS; const js = new JS(); Members compiler :JSCompiler JavaScript compiler Type: JSCompiler Source: JS.js, line 25 Methods be(inPath, outPath [, lintPaths] [, callback]) Wraps JSCompiler#be to add static analysis and linting Parameters: Name Type Argument Default Description inPath string the input path outPath string the output path lintPaths Array.&lt;string&gt; &lt;optional&gt; [] an array of paths to files/directories to lint callback function &lt;optional&gt; function () {} a callback function Source: JS.js, line 134 Returns: Type void Example compiler.be('/path/to/an/input/file.js', '/path/to/the/output/file.js', ['/lint/this/directory/too'], () =&gt; { // the code has passed all the checks and has been compiled successfully }); fe(inPath, outPath [, lintPaths] [, callback]) Wraps JSCompiler#fe to add static analysis and linting Parameters: Name Type Argument Default Description inPath string the input path outPath string the output path lintPaths Array.&lt;string&gt; &lt;optional&gt; [] an array of paths to files/directories to lint callback function &lt;optional&gt; function () {} a callback function Source: JS.js, line 156 Returns: Type void Example compiler.fe('/path/to/an/input/file.js', '/path/to/the/output/file.js', ['/lint/this/directory/too'], () =&gt; { // the code has passed all the checks and has been compiled successfully }); lint(paths, callback) Performs linting Parameters: Name Type Description paths Array.&lt;string&gt; an array of paths to files/directories to lint callback function a callback function, invoked only when successfully linted Source: JS.js, line 86 Example js.lint(['/path/to/the/input/file.js', '/lint/this/directory/too'], () =&gt; { // successfully linted }); typecheck(callback) Performs static analysis Parameters: Name Type Description callback function a callback function, invoked only when successfully typechecked Source: JS.js, line 62 Example js.typecheck(() =&gt; { // successfully typechecked }); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"JSCompiler.html":{"id":"JSCompiler.html","title":"Class: JSCompiler","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: JSCompiler JSCompiler new JSCompiler( [compress] [, options]) A JavaScript compiler Parameters: Name Type Argument Default Description compress boolean &lt;optional&gt; true if true Compiler#save will gzip compress the data options Object &lt;optional&gt; {} allows to override the default Babel options Source: JSCompiler.js, line 32 Example import {JSCompiler} from 'webcompiler'; // or - import {JSCompiler} from 'webcompiler/lib/JSCompiler'; // or - var JSCompiler = require('webcompiler').JSCompiler; // or - var JSCompiler = require('webcompiler/lib/JSCompiler').JSCompiler; const compiler = new JSCompiler(); Extends Compiler Members &lt;readonly&gt; isProduction :boolean True if the NODE_ENV environment variable is equal to production. Caution: modifying it's value directly may lead to unexpected results Type: boolean Inherited From: Compiler#isProduction Source: Compiler.js, line 21 Methods be(inPath, outPath [, callback]) Compiles a JavaScript file or a directory for the back end. Non-JavaScript files are simply copied over. Parameters: Name Type Argument Default Description inPath string the input path outPath string the output path callback function &lt;optional&gt; function () {} a callback function Source: JSCompiler.js, line 199 Returns: Type void Example compiler.be('/path/to/an/input/file.js', '/path/to/the/output/file.js', callback); fe(inPath, outPath [, callback]) Compiles, bundles (in production mode also minifies and g-zips) a JavaScript file for the front end. Parameters: Name Type Argument Default Description inPath string the input path outPath string the output path callback function &lt;optional&gt; function () {} a callback function Source: JSCompiler.js, line 224 Example compiler.fe('/path/to/an/input/file.js', '/path/to/the/output/file.js', callback); &lt;protected&gt; save(inPath, outPath, data, callback) G-zips the program if necessary and writes the results to disk. Skips the final write if the contents of the file have not changed since the previous write. Which adds a little overhead at compile time, but at the same time does not alter the last modified timestamp of the file unnecessarily. Good news for someone who is using that timestamp for public cache invalidation. Parameters: Name Type Description inPath string the input path outPath string the output path data ProgramData processed application code with source maps callback function a callback function Inherited From: Compiler#save Source: Compiler.js, line 198 Example compiler.save('/path/to/an/input/file', '/path/to/the/output/file', data, callback); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"JSLint.html":{"id":"JSLint.html","title":"Class: JSLint","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: JSLint JSLint new JSLint( [rules]) A JavaScript linter Parameters: Name Type Argument Default Description rules Object &lt;optional&gt; {} an object that lets you override default linting rules Source: JSLint.js, line 10 Example import {JSLint} from 'webcompiler'; // or - import {JSLint} from 'webcompiler/lib/JSLint'; // or - var JSLint = require('webcompiler').JSLint; // or - var JSLint = require('webcompiler/lib/JSLint').JSLint; import {join} from 'path'; const linter = new JSLint(); Methods run(paths, callback) Execute the linter Parameters: Name Type Description paths Array.&lt;string&gt; an array of paths to files/directories to lint callback JSLintCallback a callback function, accepts 1 argument: an array of error objects or null Source: JSLint.js, line 41 Example // lint &quot;index.js&quot; as well as the entire contents of the &quot;src&quot; directory linter.run([join(__dirname, 'index.js'), join(__dirname, 'src')], function (err) { if (err) { return e.forEach(e =&gt; { console.log('\\x1b[41mESLint error\\x1b[0m &quot;\\x1b[33m%s%s\\x1b[0m&quot; in \\x1b[36m%s\\x1b[0m on \\x1b[35m%s:%s\\x1b[0m', e.message, e.ruleId ? ` (${e.ruleId})` : '', e.filePath, e.line, e.column); }); } // there were no linting errors }); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"module-highlight.html":{"id":"module-highlight.html","title":"Module: highlight","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Module: highlight CodeMirror syntax highlighting that works in the browser and on Node.js Source: highlight.js, line 9 Methods &lt;static&gt; highlightArray( [code]) Using the CodeMirror editor highlights a string of text representing JavaScript program code and returns an array of plain objects describing React Elements for easy serialization/unserialization. Parameters: Name Type Argument Default Description code string &lt;optional&gt; &quot;&quot; any valid ES2015, TypeScript, JSX, Flow code Source: highlight.js, line 79 Returns: an array of plain objects describing React Elements Type Array.&lt;(string|Object)&gt; Example import {highlightArray} from 'webcompiler'; // or - import {highlightArray} from 'webcompiler/lib/highlight'; // or - var highlightArray = require('webcompiler').highlightArray; // or - var highlightArray = require('webcompiler/lib/highlight').highlightArray; highlightArray('function myScript(){return 100;}'); // [{type: 'pre', props: {className: 'CodeMirror-line'}, children: [...]}] &lt;static&gt; highlightHTML( [code]) Using the CodeMirror editor highlights a string of text representing JavaScript program code and returns an HTML string. Parameters: Name Type Argument Default Description code string &lt;optional&gt; &quot;&quot; any valid ES2015, TypeScript, JSX, Flow code Source: highlight.js, line 54 Returns: an HTML string of the pre.CodeMirror-line elements Type string Example import {highlightHTML} from 'webcompiler'; // or - import {highlightHTML} from 'webcompiler/lib/highlight'; // or - var highlightHTML = require('webcompiler').highlightHTML; // or - var highlightHTML = require('webcompiler/lib/highlight').highlightHTML; highlightHTML('function myScript(){return 100;}'); // &lt;pre class=&quot;CodeMirror-line&quot;&gt;...&lt;/pre&gt; &lt;static&gt; highlightJSX( [code]) Using the CodeMirror editor highlights a string of text representing JavaScript program code and returns an array of React elements. Parameters: Name Type Argument Default Description code string &lt;optional&gt; &quot;&quot; any valid ES2015, TypeScript, JSX, Flow code Source: highlight.js, line 105 Returns: React elements of the pre.CodeMirror-line elements Type Array.&lt;ReactElement&gt; Example import {highlightJSX} from 'webcompiler'; // or - import {highlightJSX} from 'webcompiler/lib/highlight'; // or - var highlightJSX = require('webcompiler').highlightJSX; // or - var highlightJSX = require('webcompiler/lib/highlight').highlightJSX; &lt;div className=&quot;CodeMirror cm-s-monokai&quot;&gt;{highlightJSX('function myScript(){return 100;}')}&lt;/div&gt; × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"module-jsx.html":{"id":"module-jsx.html","title":"Module: jsx","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Module: jsx Useful utilities for working with JSX. Source: jsx.js, line 13 Methods &lt;static&gt; arrayToJSX( [arr]) Converts an array of plain objects describing React Elements to an array of React Elements. Parameters: Name Type Argument Default Description arr Array.&lt;(string|Object)&gt; &lt;optional&gt; [] an array of plain objects describing React Elements Source: jsx.js, line 163 Returns: an array of React Elements Type Array.&lt;ReactElement&gt; Example import {arrayToJSX} from 'webcompiler'; // or - import {arrayToJSX} from 'webcompiler/lib/jsx'; // or - var arrayToJSX = require('webcompiler').arrayToJSX; // or - var arrayToJSX = require('webcompiler/lib/jsx').arrayToJSX; &lt;div&gt;{arrayToJSX([{type: 'h1', children: ['Hello world!']}])}&lt;/div&gt; &lt;static&gt; flatten(args) Recursively flattens args, removes falsy values and combines string values. Can be used as a simple optimization step on the JSX children-to-be to simplify the resulting DOM structure by joining adjacent text nodes together. Parameters: Name Type Argument Description args * &lt;repeatable&gt; the input values Source: jsx.js, line 130 Returns: the flattened result Type Array.&lt;*&gt; Example import {flatten} from 'webcompiler'; // or - import {flatten} from 'webcompiler/lib/jsx'; // or - var flatten = require('webcompiler').flatten; // or - var flatten = require('webcompiler/lib/jsx').flatten; flatten('lorem ', ['ipsum ', null, ['dolor ', ['sit ', ['amet']]]]); // [&quot;lorem ipsum dolor sit amet&quot;] &lt;static&gt; htmlToArray( [html]) Converts an arbitrary HTML string to an array of plain objects describing React Elements for easy serialization/unserialization. Parameters: Name Type Argument Default Description html string &lt;optional&gt; &quot;&quot; an arbitrary HTML string Source: jsx.js, line 189 Returns: an array of plain objects describing React Elements Type Array.&lt;(string|Object)&gt; Example import {htmlToArray} from 'webcompiler'; // or - import {htmlToArray} from 'webcompiler/lib/jsx'; // or - var htmlToArray = require('webcompiler').htmlToArray; // or - var htmlToArray = require('webcompiler/lib/jsx').htmlToArray; htmlToArray('&lt;h1&gt;Hello world!&lt;/h1&gt;'); // [{type: 'h1', children: ['Hello world!']}] &lt;static&gt; htmlToJSX( [html]) Converts an arbitrary HTML string to an array of React Elements. Parameters: Name Type Argument Default Description html string &lt;optional&gt; &quot;&quot; an arbitrary HTML string Source: jsx.js, line 211 Returns: an array of React Elements Type Array.&lt;ReactElement&gt; Example import {htmlToJSX} from 'webcompiler'; // or - import {htmlToJSX} from 'webcompiler/lib/jsx'; // or - var htmlToJSX = require('webcompiler').htmlToJSX; // or - var htmlToJSX = require('webcompiler/lib/jsx').htmlToJSX; &lt;div&gt;{htmlToJSX('&lt;h1&gt;Hello world!&lt;/h1&gt;')}&lt;/div&gt; × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"module-markdown.html":{"id":"module-markdown.html","title":"Module: markdown","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Module: markdown Useful utilities for working with Markdown. Source: markdown.js, line 9 Methods &lt;static&gt; markdownToArray( [markdown]) Converts an arbitrary Markdown string to an array of plain objects describing React Elements for easy serialization/unserialization. Parameters: Name Type Argument Default Description markdown string &lt;optional&gt; &quot;&quot; an arbitrary Markdown string Source: markdown.js, line 41 Returns: an array of plain objects describing React Elements Type Array.&lt;(string|Object)&gt; Example import {markdownToArray} from 'webcompiler'; // or - import {markdownToArray} from 'webcompiler/lib/markdown'; // or - var markdownToArray = require('webcompiler').markdownToArray; // or - var markdownToArray = require('webcompiler/lib/markdown').markdownToArray; markdownToArray('# Hello world!'); // [{type: 'h1', children: ['Hello world!']}] &lt;static&gt; markdownToHTML( [markdown]) Converts an arbitrary Markdown string to an HTML string Parameters: Name Type Argument Default Description markdown string &lt;optional&gt; &quot;&quot; an arbitrary Markdown string Source: markdown.js, line 84 Returns: an HTML string Type string Example import {markdownToHTML} from 'webcompiler'; // or - import {markdownToHTML} from 'webcompiler/lib/markdown'; // or - var markdownToHTML = require('webcompiler').markdownToHTML; // or - var markdownToHTML = require('webcompiler/lib/markdown').markdownToHTML; markdownToHTML('# Hello world!'); // &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;static&gt; markdownToJSX( [markdown]) Converts an arbitrary Markdown string to an array of React Elements Parameters: Name Type Argument Default Description markdown string &lt;optional&gt; &quot;&quot; an arbitrary Markdown string Source: markdown.js, line 63 Returns: an array of React Elements Type Array.&lt;ReactElement&gt; Example import {markdownToJSX} from 'webcompiler'; // or - import {markdownToJSX} from 'webcompiler/lib/markdown'; // or - var markdownToJSX = require('webcompiler').markdownToJSX; // or - var markdownToJSX = require('webcompiler/lib/markdown').markdownToJSX; &lt;div&gt;{markdownToJSX('# Hello world!')}&lt;/div&gt; × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"NativeProcess.html":{"id":"NativeProcess.html","title":"Class: NativeProcess","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: NativeProcess NativeProcess new NativeProcess(task) Encapsulates a ChildProcess instance of a task Parameters: Name Type Description task string a process name Source: NativeProcess.js, line 7 Example import {NativeProcess} from 'webcompiler'; // or - import {NativeProcess} from 'webcompiler/lib/NativeProcess'; // or - var NativeProcess = require('webcompiler').NativeProcess; // or - var NativeProcess = require('webcompiler/lib/NativeProcess').NativeProcess; const mkdir = new NativeProcess('mkdir'); Methods kill() Kills the process if any is running Source: NativeProcess.js, line 93 Example someEpensiveProcess.kill(); run( [callback] [, args] [, opts]) Execute the command Parameters: Name Type Argument Default Description callback NativeProcessCallback &lt;optional&gt; function () {} a callback function args Array.&lt;string&gt; &lt;optional&gt; [] an array of arguments to pass to the process opts Object &lt;optional&gt; {} a configuration object for the process Source: NativeProcess.js, line 48 Returns: Type void Example mkdir.run(error =&gt; { if (error) { return console.error(error); } // created a directory named &quot;example&quot; in cwd }, ['example']); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"SASS.html":{"id":"SASS.html","title":"Class: SASS","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: SASS SASS new SASS( [compress] [, includePaths] [, excludeLinter] [, importOnceOptions]) SASS compilation tools Parameters: Name Type Argument Default Description compress boolean &lt;optional&gt; true if true Compiler#save will gzip compress the data includePaths Array.&lt;string&gt; &lt;optional&gt; [] an array of additional include paths excludeLinter Array.&lt;string&gt; &lt;optional&gt; [] names of linters to exclude importOnceOptions Object &lt;optional&gt; {} an object that lets you override default importOnce resolver configuration Source: SASS.js, line 7 Example import {SASS} from 'webcompiler'; // or - import {SASS} from 'webcompiler/lib/SASS'; // or - var SASS = require('webcompiler').SASS; // or - var SASS = require('webcompiler/lib/SASS').SASS; const sass = new SASS(); Members compiler :SASSCompiler SCSS compiler Type: SASSCompiler Source: SASS.js, line 25 Methods fe(inPath, outPath [, lintPaths] [, callback]) Wraps SASSCompiler#fe to add linting Parameters: Name Type Argument Default Description inPath string the input path outPath string the output path lintPaths Array.&lt;string&gt; &lt;optional&gt; [] an array of paths to files/directories to lint callback function &lt;optional&gt; function () {} a callback function Source: SASS.js, line 74 Returns: Type void Example compiler.fe('/path/to/an/input/file.js', '/path/to/the/output/file.js', ['/lint/this/directory/too'], () =&gt; { // the code has passed all the checks and has been compiled successfully }); lint(paths, callback) Performs linting Parameters: Name Type Description paths Array.&lt;string&gt; an array of paths to lint callback function a callback function Source: SASS.js, line 52 Example sass.lint(['/path/to/the/input/file.scss', '/lint/this/directory/too'], () =&gt; { // successfully linted }); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"SASSCompiler.html":{"id":"SASSCompiler.html","title":"Class: SASSCompiler","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: SASSCompiler SASSCompiler new SASSCompiler( [compress] [, includePaths] [, importOnceOptions]) A SASS compiler Parameters: Name Type Argument Default Description compress boolean &lt;optional&gt; true if true Compiler#save will gzip compress the data includePaths Array.&lt;string&gt; &lt;optional&gt; [] an array of additional include paths importOnceOptions Object &lt;optional&gt; {} an object that lets you override default importOnce resolver configuration Source: SASSCompiler.js, line 16 Example import {SASSCompiler} from 'webcompiler'; // or - import {SASSCompiler} from 'webcompiler/lib/SASSCompiler'; // or - var SASSCompiler = require('webcompiler').SASSCompiler; // or - var SASSCompiler = require('webcompiler/lib/SASSCompiler').SASSCompiler; const compiler = new SASSCompiler(); Extends Compiler Members &lt;readonly&gt; isProduction :boolean True if the NODE_ENV environment variable is equal to production. Caution: modifying it's value directly may lead to unexpected results Type: boolean Inherited From: Compiler#isProduction Source: Compiler.js, line 21 Methods &lt;static&gt; autoprefix(path, data, callback) Auto-prefixes the compiled code Parameters: Name Type Description path string a path to the file data ProgramData the actual program data to auto-prefix callback ProgramDataCallback a callback function Source: SASSCompiler.js, line 62 Example SASSCompiler.autoprefix('/path/to/the/output/file.css', data, result =&gt; { // successfully added the vendor prefixes }); fe(inPath, outPath [, callback]) Compiles, auto-prefixes and optionally minifies and g-zips in the production mode Parameters: Name Type Argument Default Description inPath string a full system path to the input file outPath string a full system path to the output file callback function &lt;optional&gt; function () {} a callback function Source: SASSCompiler.js, line 95 Example compiler.fe('/path/to/the/input/file.scss', '/path/to/the/output/file.css', () =&gt; { // compiled successfully }); &lt;protected&gt; save(inPath, outPath, data, callback) G-zips the program if necessary and writes the results to disk. Skips the final write if the contents of the file have not changed since the previous write. Which adds a little overhead at compile time, but at the same time does not alter the last modified timestamp of the file unnecessarily. Good news for someone who is using that timestamp for public cache invalidation. Parameters: Name Type Description inPath string the input path outPath string the output path data ProgramData processed application code with source maps callback function a callback function Inherited From: Compiler#save Source: Compiler.js, line 198 Example compiler.save('/path/to/an/input/file', '/path/to/the/output/file', data, callback); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "},"SASSLint.html":{"id":"SASSLint.html","title":"Class: SASSLint","body":" Documentation Modules highlightjsxmarkdown Classes CompilerDevServerDocumentationJSJSCompilerJSLintNativeProcessSASSSASSCompilerSASSLint Global watchyaml Class: SASSLint SASSLint new SASSLint(excludeLinter) A SASS linter Parameters: Name Type Argument Description excludeLinter string &lt;repeatable&gt; names of linters to exclude Source: SASSLint.js, line 9 Example import {SASSLint} from 'webcompiler'; // or - import {SASSLint} from 'webcompiler/lib/SASSLint'; // or - var SASSLint = require('webcompiler').SASSLint; // or - var SASSLint = require('webcompiler/lib/SASSLint').SASSLint; import {join} from 'path'; const linter = new SASSLint(); Methods run(paths, callback) Execute the linter Parameters: Name Type Description paths Array.&lt;string&gt; an array of paths to files/directories to lint callback function a callback function, accepts 1 argument: an error message or null Source: SASSLint.js, line 50 Example // lint &quot;style.scss&quot; as well as the entire contents of the &quot;sass&quot; directory linter.run([join(__dirname, 'style.scss'), join(__dirname, 'sass')], error =&gt; { if (error) { return console.error(error); } // there were no linting errors }); × Search results Close Documentation generated by JSDoc 3.4.0 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
